[{" ": []},
{" ": []},
{" ": ["<div class=\"post-text\" itemprop=\"text\">\r\n<p>You can use <code>pthread_kill</code> which let you signal a given thread. You can then use a daemon thread that calls <code>sleep</code> and <code>pthread_kill</code> in a controlled loop to clock your given thread.</p>\n\n<p>If you care about global process timers interactions with sleep, then you can use <code>usleep</code> (or <code>nanosleep</code>).</p>\n    </div>"]},
{" ": ["<div class=\"post-text\" itemprop=\"text\">\r\n<p>Try to stare at the following line in your code, for a minute or two, and see if you can figure out the answer yourself:</p>\n\n<pre><code>for (g = 0; g &lt; 1; g++)\n</code></pre>\n\n<p>P.S. In addition to incrementing <code>g</code> in the for-loop itself, you're also incrementing it in the body of the loop as well. So, this won't work for several reasons.</p>\n    </div>"]},
{" ": ["<div class=\"post-text\" itemprop=\"text\">\r\n<p>Your load function looks OK. In your unload function you must first descend all nodes, then free the bottom node, then go one level up etcetera:</p>\n\n<pre><code>void recursive_free (node* node_to_free)\n{\n    for (int i = 0; i &lt; NB_NODES; i++)\n    {\n        // if children found\n        if (node_to_free-&gt;children[i])\n        {\n            recursive_free(node_to_free-&gt;children[i]);\n        }\n    }\n    free(node_to_free);\n}\n</code></pre>\n    </div>"]},
{" ": ["<div class=\"post-text\" itemprop=\"text\">\r\n<ol>\n<li><p>Your <code>for</code> loop only has one line of code inside of it,</p>\n\n<pre><code>printf(\"\\n Enter Number %d\\n\", i);\n</code></pre>\n\n<p>so the output is correct.</p></li>\n<li><p>The <code>main()</code> must return <code>int</code>.</p></li>\n<li>You <strong>must</strong> check the return value of <code>scanf()</code>.</li>\n<li><p>You can use something like this</p>\n\n<pre><code>#include &lt;stdio.h&gt;\n\nint calsum(int x, int y, int z);\nint getinteger();\n\nint main()\n{\n    int a, b, c, z;\n\n    a = getinteger(1);\n    b = getinteger(2);\n    c = getinteger(3);\n\n    z = calsum(a, b, c);\n\n    printf(\"\\nSum = %d\", z);\n\n    return 0;\n}\n\nint calsum(int x, int y, int z)\n{\n    int d;\n    d = x + y  +z;\n    return d;\n}\n\nint getinteger(int index)\n{\n    int value;\n    printf(\"Enter the %dth number &gt; \", index);\n    while (scanf(\"%d\", &amp;value) != 1)\n    {\n        int chr;\n        while (((chr = getchar()) != '\\n') &amp;&amp; (chr != EOF))\n            continue;\n        printf(\"Invalid input -- try again\\n\");\n        printf(\"Enter the %dth number &gt; \", index);\n    }\n    return value;\n}\n</code></pre></li>\n</ol>\n    </div>", "<div class=\"post-text\" itemprop=\"text\">\r\n<p>You can use arrays for that</p>\n\n<pre><code>int a[3], i, sum;\nfor (i = 0; i &lt; 3 ; i++)\n{\n    printf(\"\\n Enter Number %d\\n\", i+1);\n    scanf(\"%d\", &amp;a[i]);\n}\nsum = calsum(a[0], a[1], a[2]);\n</code></pre>\n    </div>"]},
{" ": ["<div class=\"post-text\" itemprop=\"text\">\r\n<p>The OS will handle the memory for thread-local storage (TLS), and maintain both that <code>%gs</code> [or it's base address] is updated when the next thread is loaded, and that memory is allocated [1] when a new thread is created.</p>\n\n<p>The compiler &amp; linker is responsible for calculating the size and respective offsets into the TLS - in this case, it would seem that the implementation uses negative offsets from the base-address, so your particular variable is at -0x30 from <code>%gs</code>.</p>\n\n<p>[When you say \"I know <code>%gs</code> is 0x080fd840, you mean that the base-address for the segment is that value, right? Since <code>%gs</code> would be a 16-bit index into a x86 descriptor-table]</p>\n\n<p>[1] This may mean that the OS just makes a virtual address available for the TLS, but that the actual allocation of PHYSICAL memory happens \"as needed\", in the same way that an executable file, shared library or large memory allocation is done.</p>\n    </div>"]},
{" ": []},
{" ": ["<div class=\"post-text\" itemprop=\"text\">\r\n<p>When you declared your variables</p>\n\n<pre><code>    int i = 0;\n    int n;\n    char c;\n    char s[4];\n</code></pre>\n\n<p>assuming the stack overflows \"up\" past <code>c</code>, you are relying upon an assumption which may not be true, i.e., that the variables are immediately adjacent on the stack.  This may not be true because there may be a \"stack guard\" or \"stack canary\" between variables.</p>\n\n<p>To read more about this, look for \"stack guard\" and \"stack canaries\":</p>\n\n<ul>\n<li><a href=\"http://www.cse.scu.edu/~tschwarz/coen152_05/Lectures/BufferOverflow.html\" rel=\"nofollow\">COEN 152 Computer Forensics: Buffer Overflow Attack</a></li>\n<li><a href=\"ftp://ftp.uvsq.fr/pub/gcc/summit/2003/Stackguard.pdf\" rel=\"nofollow\">StackGuard: Simple Stack Smash Protection for GCC</a></li>\n<li><a href=\"http://www.coresecurity.com/files/attachments/StackGuard.pdf\" rel=\"nofollow\">Four different tricks to bypass StackShield and\nStackGuard protection</a></li>\n<li><a href=\"http://security.stackexchange.com/questions/20497/stack-overflows-defeating-canaries-aslr-dep-nx\">Stack Overflows - Defeating Canaries, ASLR, DEP, NX</a></li>\n<li><a href=\"http://duartes.org/gustavo/blog/post/epilogues-canaries-buffer-overflows/\" rel=\"nofollow\">Epilogues, Canaries, and Buffer Overflows</a></li>\n</ul>\n    </div>"]},
{" ": []},
{" ": ["<div class=\"post-text\" itemprop=\"text\">\r\n<p>your code is not so clear nor easy to read. to help you, i wrote this piece of code that you can use it in your daily codding and that can make your life easier. wish this can help.</p>\n\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;conio.h&gt;\n\n\n/*__________________________________________________________________________________\n*/\nint YesNoQuetion(char *prompt){\n    int r=0,c;\n    printf(\"%s (Y/N) : \",prompt);\n    while(1){\n        c=_getch();\n        if(c=='n' || c=='N' || c=='y' || c=='Y'){\n            printf(\"%c\\x8\",c);\n            r=c;\n        }else{\n            if( (c=='\\n'||c=='\\r') &amp;&amp; r)\n                break;\n            r=0;\n            printf(\"%d\\x8\\x7\",c);\n        }\n    }\n    printf(\"%s\\n\",(r=='y'|| r=='Y')?\"Yes\":\"No\");\n    return (r=='y'|| r=='Y');\n\n}\n/*__________________________________________________________________________________\n*/\nint input(char *prompt,char *buff){\n    printf(\"%s :\\t\",prompt);\n    return scanf(\"%s\",buff);\n}\n\n/*__________________________________________________________________________________\n*/\n\nint main (void)\n{\n\n\n    char firstname[50];\n    char lastname[50];\n    printf(\"This is a little code that will help you create a clean code\\n\\n\");\n    printf(\"Please enter your first and last name\\n\");\n\n    input(\"First name\",firstname);\n    input(\"Last name\",lastname);\n\n    if (YesNoQuetion(\"Do you realy want to know?\"))\n    {\n       printf(\"\\nThat's good '%s, %s', you just pressed Yes\\n\",firstname,lastname);\n    }\n    else{\n         printf(\"\\nYou answerd No, that is also good\\n\");;\n    }\n\n  return 0;\n}\n</code></pre>\n    </div>"]},
{" ": ["<div class=\"post-text\" itemprop=\"text\">\r\n<p>You dereference a NULL pointer here, causing the segfault:</p>\n\n<pre><code>//Saving the least square problem as a vector_t:\nvector_t * x = NULL;\nx-&gt;n = mb;\nx-&gt;v = B;\n</code></pre>\n\n<p>Maybe you should use/create a new <code>vector_t</code> instead of just a pointer to a <code>vector_t</code>?</p>\n    </div>"]},
{" ": ["<div class=\"post-text\" itemprop=\"text\">\r\n<p>Redirections are not obtained this way. <code>&gt;</code> (or similar) is a syntax to make redirection in a shell. The shell interprets the command line and make redirections before <code>exec</code>ing the command, this way :</p>\n\n<pre><code>pid = fork();\nswitch(pid) {\ncase 0:\n  d = open(\"myfile\",O_WRONLY);\n  dup2(d,STDOUT_FILENO); // redirect *stdout* to open file d by duplicating it\n  close(d); // now unused d (d is a duplicate of *stdout*\n  exec**(...); // now mutate to a new code which inherits open file descriptors\n  exit(1);\n  break;\ncase -1: // error case of fork\n  break;\ndefault:\n  wait(NULL); // or whatever you want, don't wait for *background style*\n  break;\n}\n</code></pre>\n    </div>", "<div class=\"post-text\" itemprop=\"text\">\r\n<p>Assuming <code>args</code> is the <code>argv</code> passed to the <code>main()</code> function<sup>1</sup>:</p>\n\n<p>Your program invokes <em>Undefined Behavior</em></p>\n\n<pre><code>while (args[i] != NULL)\n{\n    printf(\"%s\\n\", args[i]);\n    i++;\n}\n</code></pre>\n\n<p>At the end of this loop, <code>i</code> has a value beyond the bounds of the <code>args</code> array. Thus</p>\n\n<pre><code>args[i] = \"&gt;\";\nargs[i + 1] = \"a.log\";\n</code></pre>\n\n<p>tries to write there at the forbidden location, invoking undefined behavior.</p>\n\n<hr>\n\n<p><sup>1</sup><sub>It's not clear because apparently some code is missing</sub></p>\n    </div>"]},
{" ": []},
{" ": []},
{" ": ["<div class=\"post-text\" itemprop=\"text\">\r\n<p>If you're using the DLL from the link you supplied, it's probably failing because it's attempting to write to the root of the system drive (<code>\"C:\\\\temp.txt\",</code>). Change this path to something your target process can write to.</p>\n    </div>"]},
{" ": []},
{" ": []},
{" ": []},
{" ": ["<div class=\"post-text\" itemprop=\"text\">\r\n<p>Problem is that</p>\n\n<pre><code> FILE *text;\n text=fopen(\"output.txt\",\"w\");\n fprintf(text,\"Name:%s\\nNumber:%d\\n\",a[i].name,a[i].num);\n fclose(text);\n</code></pre>\n\n<p>should be inside the loop, and it's outside it. What's happening is that it uses the last value for i (n) and is essentially printing from random memory locations....</p>\n    </div>"]},
{" ": ["<div class=\"post-text\" itemprop=\"text\">\r\n<p>Try this:</p>\n\n<pre><code>typedef struct SERVER {\n  ....\n} SERVER;\n\ntypedef struct PATH {\n  ....\n} PATH;\n</code></pre>\n\n<p>You see, you use <code>struct SERVER</code> and <code>struct PATH</code> but you haven't declared these. You did declare a type <code>SERVER</code> and a type <code>PATH</code> using a <code>typedef</code> on an unnamed struct.</p>\n\n<p>Alternatively, you could leave your structs as they are, and use <code>sizeof(PATH*)</code> and <code>sizeof(STRUCT*)</code>.</p>\n    </div>", "<div class=\"post-text\" itemprop=\"text\">\r\n<p>There are several issues here:</p>\n\n<pre><code>SERVER* topology = malloc(sizeof(struct SERVER*)* 10 );\n...\nPATH* paths = malloc(sizeof(struct PATH*)*10);\n</code></pre>\n\n<ul>\n<li>You have a type called <code>SERVER</code>, which is a typedef of anonymous struct.  You don't have <code>struct SERVER</code> defined, so use <code>SERVER</code> instead of <code>struct SERVER</code>.  The same applies to <code>PATH</code>.</li>\n<li>You're allocating space for 10 pointers to <code>SERVER</code>, however <code>topology</code> is a pointer to <code>SERVER</code>, which means it can act as an array of <code>SERVER</code>, not an array of <code>SERVER *</code>, which is how you're using it.  This is why you're getting an error when calling <code>free</code>, since <code>topology[i]</code> is a <code>SERVER</code>, not a <code>SERVER *</code>.  Similarly for <code>PATH</code> as well.</li>\n</ul>\n\n<p>For this to work properly, you would need to define <code>topology</code> and <code>paths</code> as follows:</p>\n\n<pre><code>SERVER **topology = malloc(sizeof(SERVER *) * 10 );\nPATH **paths = malloc(sizeof(PATH *) * 10);\n</code></pre>\n\n<p>Alternately, instead of allocating an array of pointers, then allocating individual elements, you could instead keep your current definitions and allocate the whole array at once:</p>\n\n<pre><code>SERVER *topology = malloc(sizeof(SERVER) * 10);\nPATH *paths = malloc(sizeof(PATH) * 10);\n</code></pre>\n\n<p>Then clean up like this:</p>\n\n<pre><code>free(topology);\nfree(paths);\n</code></pre>\n    </div>", "<div class=\"post-text\" itemprop=\"text\">\r\n<p>Try remove struct from sizeof.</p>\n    </div>"]},
{" ": ["<div class=\"post-text\" itemprop=\"text\">\r\n<p>just read to EOF and save the return fread, <code>The fread function returns the number of elements read.</code></p>\n\n<pre><code> int s = 0, size = 0;\n    char c[2];\n    c[1] = '\\0';\n    while((s=fread(c,sizeof(char), 1,theFile)) != 0) \n    size += s;\n</code></pre>\n\n<p>also can replace type <code>int</code> to <code>size_t</code>.</p>\n    </div>", "<div class=\"post-text\" itemprop=\"text\">\r\n<p>this will get the size of the file, in bytes, using fread()</p>\n\n<p>Note: this will leave the 'file pointer' at the end of the file</p>\n\n<p>Note: fread() returns 0 at EOF, not EOF</p>\n\n<p>Note: when exited the while loop, could add checking of errno to assure no I/O error occurred.</p>\n\n<pre><code>size_t getFileLength( FILE *fp )\n{\n    size_t fileLen = 0;\n    size_t charCount;\n    char c[2];\n\n    while((charCount=fread(c, 1, 1, fp))) \n    {\n        fileLen += charCount;\n    }\n\n    return fileLen;\n} // end function: getFileLength\n</code></pre>\n    </div>"]},
{" ": ["<div class=\"post-text\" itemprop=\"text\">\r\n<p>it is a <a href=\"http://code.opencv.org/issues/4395\" rel=\"nofollow\">known issue</a> </p>\n\n<p>i personally solved the problem by merging <a href=\"https://github.com/Itseez/opencv/pull/2947/files\" rel=\"nofollow\">deleted part</a> again and build dlls.</p>\n\n<p>here <a href=\"https://github.com/sturkmen72/opencv_samples/blob/master/cap.cpp\" rel=\"nofollow\">cap.cpp</a> and <a href=\"https://github.com/sturkmen72/opencv_samples/blob/master/cap_dshow.cpp\" rel=\"nofollow\">cap_dshow.cpp</a></p>\n\n<p>if you rebuild OpenCV 3.0 dll'd using these files you will solve your problem. otherwise you can open an issue <a href=\"https://github.com/Itseez/opencv/issues\" rel=\"nofollow\">here</a> describing your problem and wait a solution from developers or use OpenCV 2.4.12</p>\n    </div>"]},
{" ": []},
{" ": ["<div class=\"post-text\" itemprop=\"text\">\r\n<p>You need a space between <code>scanf(\"</code> and the <code>%c</code> for it to work correctly:</p>\n\n<pre><code>scanf(\" %c\", &amp;choice);\n</code></pre>\n\n<p>And you also need to use &amp;choice, not choice!</p>\n\n<p>EDIT: While you're at it, you might want to look into <code>do while()</code> for that loop (unless the professor specifically said to use a <code>break</code>) - <code>do while</code> works great when validating user input!</p>\n    </div>", "<div class=\"post-text\" itemprop=\"text\">\r\n<p>Better still, use fgetc(). scanf() should always be a last resort.</p>\n    </div>", "<div class=\"post-text\" itemprop=\"text\">\r\n<p>fflush() is not defined by ISO for input streams.  It is defined in Microsoft's C runtime library, but is not portable.</p>\n\n<p>While the \"space before %c\" solution may work when the user enters the expected data, it will fail in many ways; try entering \"y n y n\" for example.  Console input is lin-oriented; your best bet is to ensure that you discard the entire line thus:</p>\n\n<pre><code>scanf( \"%c\", choice ) ;\nwhile( choice != '\\n' &amp;&amp; getchar() != '\\n' ) /* do nothing*/ ;\n</code></pre>\n    </div>", "<div class=\"post-text\" itemprop=\"text\">\r\n<p>First of all I will keep it brief.Because of insufficient points to submit a comment \nIf we can see that number of o/p is (one + the no of charcter)\nThis is beacuse when we hit enter after entering the characters '\\n' which is non-printable character also gets added after your string.</p>\n\n<pre><code>$ ./run\nplease enter [y]es, [n]o or [m]aybe: y&lt;return&gt;\nyou selected yes!\nPlease enter only 'y', 'n' or 'm'!  -----------&gt; it is due to reading of the '\\n' by scanf\n</code></pre>\n\n<blockquote>\n  <p>EDITED\n  Due to insufficient points I could post this as a comment.This is a workaround of the above answers</p>\n</blockquote>\n    </div>"]},
{" ": ["<div class=\"post-text\" itemprop=\"text\">\r\n<p>this posted code:</p>\n\n<pre><code>void novo_ProcessoF(int sinal){\n    printf(\"Est\u00e1 a fazer o noprocessoF\");\n    if(sinal==SIGALRM){\n            int n = fork();\n            if(n==0){ //Se o processo \u00e9 filho\n                    execl(\"Trabalho2/ubertask.c\",\"./ubertask\",NULL);\n                    wait(NULL);\n                    alarm(2);\n            }\n    }\n}\n</code></pre>\n\n<p>leaves much to be desired.  Suggest:</p>\n\n<pre><code>void novo_ProcessoF(int sinal)\n{\n    // in general, it is a bad idea to call printf() in a signal handler\n    // as printf() also uses signals\n    // appended '\\n' so will be immediately output\n    printf(\"Est\u00e1 a fazer o noprocessoF\\n\");\n\n    if(sinal==SIGALRM)\n    {\n        pid_t pid = fork(); // pid_t defined in unistd.h\n        // test for all three return conditions from fork()\n        if(0 == pid)\n        { //Se o processo \u00e9 filho -- child\n            execl( \"./upertask\" ,\"./ubertask\",NULL);\n            perror( \"execl failed\");\n            exit( EXIT_FAILURE );  // exit() and EXIT_FAILURE defined in stdlib.h\n        }\n\n        else if( 0 &lt; pid )\n        { // parent\n            wait(NULL);\n            alarm(2);\n        }\n\n        else // if( 0 &gt; pid )\n        { // fork failed\n            perror( \"fork failed\" );\n            exit( EXIT_FAILURE );\n        }\n    }\n}\n</code></pre>\n    </div>"]},
{" ": ["<div class=\"post-text\" itemprop=\"text\">\r\n<p>Pass address of <code>x</code> and <code>y</code> as arguments to function. Right now they are local variables, changes are not made to original variables .</p>\n\n<p>Do as follows-</p>\n\n<pre><code>void swap(int *x,int *y){\n /*            dereference pointers and  swap    */\n}\n</code></pre>\n\n<p>And call in <code>main</code> like this -</p>\n\n<pre><code>swap(&amp;x,&amp;y);\n</code></pre>\n    </div>", "<div class=\"post-text\" itemprop=\"text\">\r\n<p>What you are doing is passing parameter by value. It means that during the function call, copies of parameters are created. So inside the function you are working on copies of actual variables.</p>\n\n<p>Instead you need to pass it as a reference. Please read more about pass-by-value vs pass-by-reference.</p>\n\n<pre><code>#include &lt;stdio.h&gt;\nvoid swap(int&amp; x,int&amp; y)    //Instead of passing by value just pass by reference\n{\n    int temp=x;\n    x=y;\n    t=yemp;\n}\nint main() {\n    int a=3,b=4;\n    swap(a,b);\n    printf(\"%d %d\\n\",a,b);\n\n    return 0;\n}\n</code></pre>\n\n<p><strong>EDIT</strong>:\nC does not have references. Above code will work in c++ instead. To make in work in C, just use pointers and de-reference it inside the function.</p>\n    </div>"]},
{" ": ["<div class=\"post-text\" itemprop=\"text\">\r\n<p>In Debian, you can find the <strong>gnu c reference manual</strong> in this package:</p>\n\n<p>Debian Package: <a href=\"https://packages.debian.org/sid/glibc-doc-reference\" rel=\"nofollow\">glibc-doc-reference</a></p>\n\n<p>Same package name for <a href=\"https://launchpad.net/ubuntu/utopic/+package/glibc-doc-reference\" rel=\"nofollow\">Ubuntu</a></p>\n\n<blockquote>\n  <p><strong>Contains The GNU C Library Reference manual in info, pdf and html format.</strong></p>\n</blockquote>\n    </div>"]},
{" ": []},
{" ": ["<div class=\"post-text\" itemprop=\"text\">\r\n<p>While there are other software products being able to generate C or C++ code from Simulink models, there is no alternative to deployment which is able to generate code in some other language.</p>\n\n<p>Further searching for an answer, you may find an often mentioned idea: Wrap your Simulink simulation in an m-function, then use the Builder JA. Unfortunately this won't succeed, there is a list of functions not supported, which includes everything to open or simulate a Simulink model.</p>\n    </div>"]},
{" ": ["<div class=\"post-text\" itemprop=\"text\">\r\n<p>The problem is that those shifts are done using the type <code>int</code>, which on all modern 64-bit systems are still 32 bits. You need to use the same type as <code>map</code>, i.e. <code>unsigned long long</code>:</p>\n\n<pre><code>1ull &lt;&lt; pos\n</code></pre>\n\n<p>Note the <code>ull</code> which tells the compiler that the <code>1</code> is not an <code>int</code> but an <code>unsigned long long</code>.</p>\n    </div>", "<div class=\"post-text\" itemprop=\"text\">\r\n<p>make sure to cast the right side expression to an unsigned long long</p>\n    </div>"]},
{" ": []},
{" ": []},
{" ": []},
{" ": ["<div class=\"post-text\" itemprop=\"text\">\r\n<p>This is the expected behavior for floating point numbers.<br>\nSee \"<a href=\"https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html\" rel=\"nofollow\">What Every Computer Scientist Should Know About Floating-Point Arithmetic</a>\" for details -- or, better still: <a href=\"http://floating-point-gui.de/\" rel=\"nofollow\">http://floating-point-gui.de/</a>.</p>\n\n<p>You'll also find that using floating point numbers for currency is not recommended because of the same imprecision.</p>\n\n<hr>\n\n<p>In order to avoid implementation errors, consider replacing your algorithm with <code>strtof()</code> instead -- <a href=\"http://en.cppreference.com/w/c/string/byte/strtof\" rel=\"nofollow\">http://en.cppreference.com/w/c/string/byte/strtof</a>. </p>\n    </div>", "<div class=\"post-text\" itemprop=\"text\">\r\n<p>If you can't use the standard library functions (which I highly recommend you do), this answer may help you:</p>\n\n<p><a href=\"http://stackoverflow.com/a/4392789/5544939\">http://stackoverflow.com/a/4392789/5544939</a></p>\n\n<p>Also, Brain Cain is right about using floating point for currency values.  Storing each salary in cents (int) instead of dollars would be safer.</p>\n    </div>", "<div class=\"post-text\" itemprop=\"text\">\r\n<p>Si no tienes restringido el ftell para saber d\u00f3nde se encuentra el puntero del archivo podr\u00edas usar algo como en el ejemplo.</p>\n\n<p>Me he encontrado que usando 'while(feof(pf))' el programa falla, por eso he usado el m\u00e9todo de ftell para saber si he llegado al final del fichero. Espero que te sirva.</p>\n\n<pre><code>fseek(pf,0,SEEK_END);\nlength = ftell(pf);\nfseek(pf,0,SEEK_SET);\n\nwhile(ftell(pf) &lt; length)\n{\n    fscanf(pf, \"%[^,]s\", nombre);\n    fseek(pf,1,SEEK_CUR);\n    fscanf(pf, \"%[^,]s\", apellido1);\n    fseek(pf,1,SEEK_CUR);\n    fscanf(pf, \"%[^,]s\", apellido2);\n    fseek(pf,1,SEEK_CUR);\n    fscanf(pf, \"%[^,]s\", DNI);\n    fseek(pf,1,SEEK_CUR);\n    fscanf(pf, \"%lf%*c\", &amp;salario);\n\n    printf(\"%s %s %s %s: %.2lf\\n\", nombre, apellido1, apellido2, DNI, salario);\n}\n</code></pre>\n\n<p>Aunque he probado el c\u00f3digo que te han dado arriba y es mucho m\u00e1s sencillo. Modificando un poco un c\u00f3digo anterior:</p>\n\n<pre><code>while(1)\n{\n    if(fscanf(pf, \"%[^,],%[^,],%[^,],%[^,],%lf\", nombre, apellido1, apellido2, DNI, &amp;salario) != 5) break;\n    printf(\"%s %s %s %s: %.2lf\\n\", nombre, apellido1, apellido2, DNI, salario);\n}\n</code></pre>\n    </div>"]},
{" ": ["<div class=\"post-text\" itemprop=\"text\">\r\n<p>This was all solved a long time with RPC (remote procedure call) and XDR (external data representation). See <a href=\"http://tools.ietf.org/html/rfc4506.html\" rel=\"nofollow\">rfc4506</a> on xdr, and this <a href=\"http://docs.oracle.com/cd/E19253-01/816-1435/6m7rrfn6r/index.html\" rel=\"nofollow\">Sun</a> document on rpc and xdr, and this <a href=\"http://www.cs.cf.ac.uk/Dave/C/node34.html\" rel=\"nofollow\">rpcgen tutorial</a>, and <code>man rpc</code>, <code>man xdr</code>.</p>\n\n<p>Obviously, these are described for use by C.</p>\n    </div>"]},
{" ": []},
{" ": ["<div class=\"post-text\" itemprop=\"text\">\r\n<p>You need to use character constants rather than string constants.  Change the double quotes to single quotes:</p>\n\n<pre><code>char a[13][4] = {'C', 'D', 'H', 'S'};\n</code></pre>\n    </div>", "<div class=\"post-text\" itemprop=\"text\">\r\n<p>The declaration  </p>\n\n<pre><code>char a[13][4] = {\"C\", \"D\", \"H\", \"S\"};  \n</code></pre>\n\n<p>initializes first four rows of array <code>a</code> with four strings <code>\"C\", \"D\", \"H\"</code> and  <code>\"S\"</code>. If you want to initialize only first row with characters <code>'C', 'D', 'H'</code> and <code>'s'</code> then it should be like  </p>\n\n<pre><code>char a[13][4] = {{'C', 'D', 'H', 'S'}};  \n</code></pre>\n\n<p>Other elements of array will be initialized to <code>'\\0'</code> character. </p>\n    </div>"]},
{" ": ["<div class=\"post-text\" itemprop=\"text\">\r\n<p>In order to do what you want you have to actually allocate space for your vector.</p>\n\n<pre><code>vector_t * x = malloc(sizeof(vector_t));\nx-&gt;n = 3;\nx-&gt;v = malloc(3 * sizeof(double));\nx-&gt;v[0]=B[0];\nx-&gt;v[1]=B[1];\nx-&gt;v[2]=B[2];\n</code></pre>\n\n<p>You must also be sure you <code>free</code> the space you allocate with <code>malloc</code> when you are done with it</p>\n\n<pre><code>free(x-&gt;v);\nfree(x);\n</code></pre>\n    </div>"]},
{" ": []},
{" ": []},
{" ": ["<div class=\"post-text\" itemprop=\"text\">\r\n<p>In your example, you should use <code>*a = c;</code> since you only want to copy a single value.\nUse <code>memcpy</code>, if you need to copy several consecutive elements of an array.</p>\n    </div>", "<div class=\"post-text\" itemprop=\"text\">\r\n<p>It is implementation specific. Some compilers, including <a href=\"http://gcc.gnu.org/\" rel=\"nofollow\">GCC</a>, are able to optimize quite well (with <code>gcc -O2</code> at least), calls to  standard functions <code>memcpy</code> and to <code>memset</code> (which, as my former colleague Pascal Cuoq commented, may be inlined to efficient assignment machine code); sometimes, GCC is even able to optimize some assignment to some structures as calls to <code>memcpy</code> (sometimes, calling an efficient <code>memcpy</code> routine is faster for large enough <code>struct</code>, including for structure assignment; at other occasions, the call to <code>memcpy</code>, transformed via some <code>__builtin_memcpy</code>, is inlined as an efficient assignment code, perhaps even going thru registers without using any memory)</p>\n\n<p>You could compile your <code>foo.c</code> example with <code>gcc -fverbose-asm -O2 -march=native -S foo.c</code> then look into the generated <code>foo.s</code></p>\n\n<p>So if you use a <em>recent</em> <a href=\"http://gcc.gnu.org/\" rel=\"nofollow\">GCC</a> or <a href=\"http://clang.llvm.org/\" rel=\"nofollow\">Clang/LLVM</a> compiler (or some other good compiler) with <em>optimizations enabled</em>, you should <strong>use <code>memcpy</code> and <code>memset</code>...</strong></p>\n\n<p>In other words, <code>memcpy(a, &amp;c, sizeof(int));</code> can be optimized as efficiently as <code>*a = c;</code> (and if you define a \"type generic\" macro e.g. using <a href=\"http://en.cppreference.com/w/c/language/generic\" rel=\"nofollow\">_Generic</a> from C99, you would use <code>memcpy</code> and it should be optimized efficiently).</p>\n    </div>", "<div class=\"post-text\" itemprop=\"text\">\r\n<blockquote>\n  <p>Should memcpy always be used?</p>\n</blockquote>\n\n<p>Plain and simple, <strong>no</strong>.</p>\n\n<p>Your first goal in writing code is to make it understandable and maintainable. Everyone knows what <code>*a = c</code> will do when <code>a</code> is declared as a pointer to an int and <code>c</code> is declared as an int. The compiler also knows exactly what you mean by that. You'll never see a compiler optimize your <code>*a = c</code> to a call to <code>memcpy</code> because that would be a disoptimization.</p>\n\n<p>You will see the compiler optimize <code>*a=c</code> to a call to <code>memcpy</code> when <code>c</code> is of type <code>struct AVeryLargeStruct</code> and <code>a</code> is a pointer to the same. There's no need to convert <code>*a=c</code> to <code>memcpy(a,&amp;c, sizeof(c))</code> because the compiler does that for you, <em>a gratis</em>. Write <code>*a=c</code> because that is clearer than and less error prone than is the <code>memcpy</code>.</p>\n\n<p>There are a few places where you truly do need to use <code>memcpy</code> (or <code>memmove</code>):</p>\n\n<ul>\n<li>Copying an array,</li>\n<li>Type punning, without using unions, and</li>\n<li>Copying to or from improperly aligned memory.</li>\n</ul>\n\n<p>The first is standard operating procedure; no one will be shocked on reading your code and seeing a call to <code>memcpy</code> when used in that context. The latter two are not SOP. They will make readers of your code think twice upon seeing a call to <code>memcpy</code>.</p>\n\n<p>If you use <code>memcpy</code> everywhere you are likely to make your code slower and you are even more likely to make others think there's something wrong with your code.</p>\n    </div>"]},
{" ": []},
{" ": []},
{" ": []},
{" ": ["<div class=\"post-text\" itemprop=\"text\">\r\n<p>-11ULL is the same as - (11ULL). 11ULL is an unsigned long long with value 11. If you read up how arithmetic operations on unsigned types work, if the mathematical result does not fit into the range, then the largest value + 1 is added or subtracted repeatedly. </p>\n\n<p>The mathematical result -11 doesn't fit, so the largest unsigned long long + 1 is added, and -11ULL gives ten less than the largest possible unsigned long long value. A huge positive number, not negative. </p>\n    </div>", "<div class=\"post-text\" itemprop=\"text\">\r\n<pre><code> unsigned int a=-1;\n</code></pre>\n\n<p>is the same as:</p>\n\n<pre><code> unsigned int a=0xffffffff;\n</code></pre>\n    </div>"]},
{" ": []},
{" ": ["<div class=\"post-text\" itemprop=\"text\">\r\n<p>You're using the same <code>buffer</code> for each line of the file, so each time you read a new line, the tokens on that line will overwrite the tokens from the previous line. Use <code>strdup()</code> to make copies of the tokens.</p>\n\n<pre><code>artistTokens[i++] = strdup(token);\n</code></pre>\n\n<p>Since this performs dynamic allocation using <code>malloc()</code>, you'll need to free them when you're done with the tokens.</p>\n    </div>"]},
{" ": []},
{" ": ["<div class=\"post-text\" itemprop=\"text\">\r\n<blockquote>\n  <h2>WARNING!</h2>\n  \n  <p>The following are <em>potential</em> reasons for a segmentation fault, though <strong>it is virtually impossible to list all reasons</strong>. The purpose of this list is to help in diagnosing an existing segfault. </p>\n  \n  <p>Avoiding these will not guarantee that you'll never get one, and doing one of these may cause something other than a segfault. These are called <strong>undefined behaviors</strong>, or as someone once said on USENET, \"<a href=\"http://catb.org/jargon/html/N/nasal-demons.html\" rel=\"nofollow\">it is legal for the compiler to make demons fly out of your nose.</a>\" Anything and everything can happen. You should learn which undefined behaviors exist in C and/or C++, and avoid writing code that has them!</p>\n  \n  <p><strong>The relationship between segmentation faults and undefined behavior <em>cannot</em> be stressed enough! All of the below situations that can create a segmentation fault technically have undefined behavior.</strong></p>\n  \n  <p>More information on Undefined Behavior:</p>\n  \n  <ul>\n  <li><a href=\"http://stackoverflow.com/questions/18986351/what-is-the-simplest-standard-conform-way-to-produce-a-segfault-in-c/18986406#18986406\">What is the simplest standard conform way to produce a Segfault in C?</a></li>\n  <li><a href=\"http://stackoverflow.com/q/2397984/472647\">Undefined, unspecified and implementation-defined behavior</a></li>\n  <li><a href=\"http://stackoverflow.com/questions/7961067/how-undefined-is-undefined-behavior\">How undefined is undefined behavior?</a></li>\n  </ul>\n</blockquote>\n\n<hr>\n\n<h2>What Is a Segfault?</h2>\n\n<p>In short, a segmentation fault is caused when the code attempts to access memory that it <strong>doesn't have permission to access</strong>. Every program is given a piece of memory (RAM) to work with, and for security reasons, it is only allowed to access memory in that chunk. </p>\n\n<p><strong>For a more thorough technical explanation about what a segmentation fault <em>is</em>, see <a href=\"http://stackoverflow.com/a/2346849/472647\">What is a segmentation fault?</a>.</strong></p>\n\n<p>Here are the most common reasons for a segmentation fault error. Again, <strong>these should be used in diagnosing an existing segfault</strong>. To learn how to avoid them, learn your language's <em>undefined behaviors</em>.</p>\n\n<p>This list is also <strong>no replacement for doing your own debugging work</strong>. (See that section at the bottom of the answer.) These are things you can look for, but your debugging tools are the only reliable way to zero in on the problem.</p>\n\n<hr>\n\n<h2>Accessing a NULL or uninitialized pointer</h2>\n\n<p>If you have a pointer that is NULL (<code>ptr=0</code>) or that is completely uninitialized (it isn't set to anything at all yet), attempting to access or modify using that pointer has undefined behavior.</p>\n\n<pre><code>int* ptr = 0;\n*ptr += 5;\n</code></pre>\n\n<p>Since a failed allocation (such as with <code>malloc</code> or <code>new</code>) will return a null pointer, you should always check that your pointer is not NULL before working with it.</p>\n\n<p>Note also that even <em>reading</em> values (without dereferencing) of uninitialized pointers (and variables in general) is undefined behaviour.</p>\n\n<p>See also:</p>\n\n<ul>\n<li><a href=\"http://stackoverflow.com/q/23438915/472647\">How to detect if variable uninitialized/catch segfault in C</a></li>\n</ul>\n\n<hr>\n\n<h2>Accessing a dangling pointer</h2>\n\n<p>If you use <code>malloc</code> or <code>new</code> to allocate memory, and then later <code>free</code> or <code>delete</code> that memory through pointer, that pointer is now considered a <strong>dangling pointer</strong>. Dereferencing it (as well as simply <em>reading</em> its value - granted you didn't assign some new value to it such as NULL) is undefined behavior, and can result in segmentation fault.</p>\n\n<pre><code>Something* ptr = new Something(123, 456);\ndelete ptr;\nstd::cout &lt;&lt; ptr-&gt;foo &lt;&lt; std::endl;\n</code></pre>\n\n<p>WARNING: If you have a case of this and it isn't throwing an error, do NOT take that to mean you can get away with it.</p>\n\n<p>See also:</p>\n\n<ul>\n<li><a href=\"http://stackoverflow.com/a/17997314/472647\">What is a dangling pointer?</a></li>\n<li><a href=\"http://stackoverflow.com/q/20723697/472647\">Why my dangling pointer doesn't cause a segmentation fault?</a></li>\n</ul>\n\n<hr>\n\n<h2>Stack overflow</h2>\n\n<p>[No, not the site you're on now, what is was <em>named</em> for.] Oversimplified, the \"stack\" is like that spike you stick your order paper on in some diners. This problem can occur when you put too many orders on that spike, so to speak. In the computer, any variable that is <em>not dynamically allocated</em> and any command that has yet to be processed by the CPU, goes on the stack.</p>\n\n<p>One cause of this might be deep or infinite recursion, such as when a function calls itself with no way to stop. Because that stack has overflowed, the order papers start \"falling off\" and taking up other space not meant for them. Thus, we can get a segmentation fault. Another cause might be the attempt to initialize a very large array: it's only a single order, but one that is already large enough by itself.</p>\n\n<pre><code>int stupidFunction(int n)\n{\n   return stupidFunction(n);\n}\n</code></pre>\n\n<p>Another cause of a stack overflow would be having too many (non-dynamically allocated) variables at once.</p>\n\n<p>int stupidArray[600851475143];</p>\n\n<p>See also: </p>\n\n<ul>\n<li><a href=\"http://stackoverflow.com/q/15283546/472647\">Segmentation Fault While Creating Large Arrays in C</a></li>\n<li><a href=\"http://stackoverflow.com/questions/3815232/seg-fault-when-initializing-array\">Seg Fault when initializing array</a></li>\n</ul>\n\n<hr>\n\n<h2>Wild pointers</h2>\n\n<p>Creating a pointer to some random location in memory is like playing Russian roulette with your code - you could easily miss and create a pointer to a location you don't have access rights to.</p>\n\n<pre><code>int n = 123;\nint* ptr = (&amp;n + 0xDEADBEEF); //This is just stupid, people.\n</code></pre>\n\n<p>As a general rule, don't create pointers to literal memory locations. Even if they work one time, the next time they might not. You can't predict where your program's memory will be at any given execution.</p>\n\n<p>See also:</p>\n\n<ul>\n<li><a href=\"http://stackoverflow.com/questions/2583656/what-is-the-meaning-of-wild-pointer-in-c\">What is the meaning of \"wild pointer\" in C?</a></li>\n</ul>\n\n<hr>\n\n<h2>Attempting to read past the end of an array</h2>\n\n<p>An array is a contiguous region of memory, where each successive element is located at the next address in memory. However, most arrays don't have an innate sense of how large they are, or what the last element is. Thus, it is easy to blow past the end of the array and never know it, especially if you're using pointer arithmetic.</p>\n\n<p>If you read past the end of the array, you may wind up going into memory that is uninitialized or belongs to something else. This is technically <strong>undefined behavior</strong>. A segfault is just one of those many potential undefined behaviors. [Frankly, if you get a segfault here, you're lucky. Others are harder to diagnose.]</p>\n\n<pre><code>// like most UB, this code is a total crapshoot.\nint arr[3] {5, 151, 478};\nint i = 0;\nwhile(arr[i] != 16)\n{\n   std::cout &lt;&lt; arr[i] &lt;&lt; std::endl;\n   i++;\n}\n</code></pre>\n\n<p>Additionally it should be noted that you are not even allowed to create (not to mention dereferencing) a pointer which points outside the array (you can create such pointer only if it points to an element within the array, or one past the end). Otherwise, you are triggering undefined behaviour.</p>\n\n<p>See also: </p>\n\n<ul>\n<li><a href=\"http://stackoverflow.com/questions/5367030/i-have-segfaults\">I have segfaults!</a></li>\n</ul>\n\n<hr>\n\n<h2>Forgetting a NUL terminator on a C string.</h2>\n\n<p>C strings are, themselves, arrays with some additional behaviors. They must be null terminated, meaning they have an <code>\\0</code> at the end, to be reliably used as strings. This is done automatically in some cases, and not in others.</p>\n\n<p>If this is forgotten, some functions that handle C strings never know when to stop, and you can get the same problems as with reading past the end of an array.</p>\n\n<pre><code>char str[3] = {'f', 'o', 'o'};\nint i = 0;\nwhile(str[i] != '\\0')\n{\n   std::cout &lt;&lt; str[i] &lt;&lt; std::endl;\n   i++;\n}\n</code></pre>\n\n<p>With C-strings, it really is hit-and-miss whether <code>\\0</code> will make any difference. You should assume it will to avoid undefined behavior.</p>\n\n<hr>\n\n<h2>Attempting to modify a string literal</h2>\n\n<p>If you assign a string literal to a char*, it cannot be modified. For example...</p>\n\n<pre><code>char* foo = \"Hello, world!\"\nfoo[7] = 'W';\n</code></pre>\n\n<p>...triggers <strong>undefined behavior</strong>, and a segmentation fault is one possible outcome.</p>\n\n<p>See also:</p>\n\n<ul>\n<li><a href=\"http://stackoverflow.com/q/1614723/472647\">Why is this string reversal C code causing a segmentation fault?</a></li>\n</ul>\n\n<hr>\n\n<h2>Mismatching Allocation and Deallocation methods</h2>\n\n<p>You must use <code>malloc</code> and <code>free</code> together, <code>new</code> and <code>delete</code> together, and <code>new[]</code> and <code>delete[]</code> together. If you mix 'em up, you can get segfaults and other weird behavior.</p>\n\n<p>See also:</p>\n\n<ul>\n<li><a href=\"http://stackoverflow.com/q/10854210/472647\">Behaviour of malloc with delete in C++</a></li>\n<li><a href=\"http://stackoverflow.com/q/33111252/472647\">Segmentation fault (core dumped) when I delete pointer</a></li>\n</ul>\n\n<hr>\n\n<h2>Errors in the toolchain.</h2>\n\n<p>A bug in the machine code backend of a compiler is quite capable of turning valid code into an executable that segfaults. A bug in the linker can definitely do this too.</p>\n\n<p>Particularly scary in that this is not UB invoked by your own code.</p>\n\n<p>That said, <strong>you should always assume the problem is you until proven otherwise.</strong></p>\n\n<hr>\n\n<h2>Other Causes</h2>\n\n<p>The possible causes of Segmentation Faults are about as numerous as the number of undefined behaviors, and there are far too many for even the standard documentation to list.</p>\n\n<p>A few less common causes to check:</p>\n\n<ul>\n<li><a href=\"http://stackoverflow.com/questions/26309300/c-code-with-undefined-results-compiler-generates-invalid-code-with-o3\">UD2 generated on some platforms due to other UB</a></li>\n<li><a href=\"http://stackoverflow.com/q/33131966/472647\">c++ STL map::operator[] done on an entry being deleted</a></li>\n</ul>\n\n<hr>\n\n<h2>DEBUGGING</h2>\n\n<p>Debugging tools are instrumental in diagnosing the causes of a segfault. Compile your program with the debugging flag (<code>-g</code>), and then run it with your debugger to find where the segfault is likely occurring.</p>\n\n<p>Recent compilers support building with <code>-fsanitize=address</code>, which  typically results in program that run about 2x slower but can detect address errors more accurately. However, other errors (such as reading from uninitialized memory or leaking non-memory resources such as file descriptors) are not supported by this method, and it is impossible to use many debugging tools and <a href=\"http://clang.llvm.org/docs/AddressSanitizer.html\" rel=\"nofollow\">ASan</a> at the same time.</p>\n\n<p><strong>Some Memory Debuggers</strong></p>\n\n<ul>\n<li>GDB | Mac, Linux</li>\n<li>valgrind (memcheck)| Linux</li>\n<li>Dr. Memory | Windows</li>\n</ul>\n\n<p>Additionally it is recommended to use static analysis tools to detect undefined behaviour - but again, they are a tool merely to help you find undefined behaviour, and they don't guarantee to find all occurrences of undefined behaviour.</p>\n\n<p>If you are really unlucky however, recompiling with debug information may rearrange the binary sufficiently that the segfault no longer occurs, a phenomenon known as a <a href=\"http://catb.org/jargon/html/H/heisenbug.html\" rel=\"nofollow\"><em>heisenbug</em></a>.</p>\n    </div>"]}]